//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.0

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of openapi.api;

class StripeSubscription {
  /// Returns a new [StripeSubscription] instance.
  StripeSubscription({
    @required this.djstripeId,
    @required this.djstripeCreated,
    @required this.djstripeUpdated,
    @required this.id,
    this.livemode,
    this.created,
    this.metadata,
    this.description,
    this.applicationFeePercent,
    this.billingCycleAnchor,
    this.billingThresholds,
    this.cancelAt,
    this.cancelAtPeriodEnd,
    this.canceledAt,
    this.collectionMethod,
    @required this.currentPeriodEnd,
    @required this.currentPeriodStart,
    this.daysUntilDue,
    this.discount,
    this.endedAt,
    this.nextPendingInvoiceItemInvoice,
    this.pendingInvoiceItemInterval,
    this.pendingUpdate,
    this.quantity,
    this.startDate,
    this.status,
    this.trialEnd,
    this.trialStart,
    this.djstripeOwnerAccount,
    this.customer,
    this.defaultPaymentMethod,
    this.defaultSource,
    this.pendingSetupIntent,
    this.plan,
    this.schedule,
    this.defaultTaxRates = const [],
  });

  int djstripeId;

  DateTime djstripeCreated;

  DateTime djstripeUpdated;

  String id;

  /// Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
  bool livemode;

  /// The datetime this object was created in stripe.
  DateTime created;

  /// A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
  Map<String, Object> metadata;

  /// A description of this object.
  String description;

  /// A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner's Stripe account each billing period.
  double applicationFeePercent;

  /// Determines the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices.
  DateTime billingCycleAnchor;

  /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.
  Map<String, Object> billingThresholds;

  /// A date in the future at which the subscription will automatically get canceled.
  DateTime cancelAt;

  /// If the subscription has been canceled with the ``at_period_end`` flag set to true, ``cancel_at_period_end`` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
  bool cancelAtPeriodEnd;

  /// If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with ``cancel_at_period_end``, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
  DateTime canceledAt;

  /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
  CollectionMethodEnum collectionMethod;

  /// End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.
  DateTime currentPeriodEnd;

  /// Start of the current period for which the subscription has been invoiced.
  DateTime currentPeriodStart;

  /// Number of days a customer has to pay invoices generated by this subscription. This value will be `null` for subscriptions where `billing=charge_automatically`.
  // minimum: -2147483648
  // maximum: 2147483647
  int daysUntilDue;

  Map<String, Object> discount;

  /// If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.
  DateTime endedAt;

  /// Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval.
  DateTime nextPendingInvoiceItemInvoice;

  /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval.
  Map<String, Object> pendingInvoiceItemInterval;

  /// If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.
  Map<String, Object> pendingUpdate;

  /// The quantity applied to this subscription. This value will be `null` for multi-plan subscriptions
  // minimum: -2147483648
  // maximum: 2147483647
  int quantity;

  /// Date when the subscription was first created. The date might differ from the created date due to backdating.
  DateTime startDate;

  /// The status of this subscription.
  StripeSubscriptionStatusEnum status;

  /// If the subscription has a trial, the end of that trial.
  DateTime trialEnd;

  /// If the subscription has a trial, the beginning of that trial.
  DateTime trialStart;

  Nested djstripeOwnerAccount;

  Nested customer;

  Nested defaultPaymentMethod;

  Nested defaultSource;

  Nested pendingSetupIntent;

  Nested plan;

  Nested schedule;

  List<Nested> defaultTaxRates;

  @override
  bool operator ==(Object other) => identical(this, other) || other is StripeSubscription &&
     other.djstripeId == djstripeId &&
     other.djstripeCreated == djstripeCreated &&
     other.djstripeUpdated == djstripeUpdated &&
     other.id == id &&
     other.livemode == livemode &&
     other.created == created &&
     other.metadata == metadata &&
     other.description == description &&
     other.applicationFeePercent == applicationFeePercent &&
     other.billingCycleAnchor == billingCycleAnchor &&
     other.billingThresholds == billingThresholds &&
     other.cancelAt == cancelAt &&
     other.cancelAtPeriodEnd == cancelAtPeriodEnd &&
     other.canceledAt == canceledAt &&
     other.collectionMethod == collectionMethod &&
     other.currentPeriodEnd == currentPeriodEnd &&
     other.currentPeriodStart == currentPeriodStart &&
     other.daysUntilDue == daysUntilDue &&
     other.discount == discount &&
     other.endedAt == endedAt &&
     other.nextPendingInvoiceItemInvoice == nextPendingInvoiceItemInvoice &&
     other.pendingInvoiceItemInterval == pendingInvoiceItemInterval &&
     other.pendingUpdate == pendingUpdate &&
     other.quantity == quantity &&
     other.startDate == startDate &&
     other.status == status &&
     other.trialEnd == trialEnd &&
     other.trialStart == trialStart &&
     other.djstripeOwnerAccount == djstripeOwnerAccount &&
     other.customer == customer &&
     other.defaultPaymentMethod == defaultPaymentMethod &&
     other.defaultSource == defaultSource &&
     other.pendingSetupIntent == pendingSetupIntent &&
     other.plan == plan &&
     other.schedule == schedule &&
     other.defaultTaxRates == defaultTaxRates;

  @override
  int get hashCode =>
  // ignore: unnecessary_parenthesis
    (djstripeId == null ? 0 : djstripeId.hashCode) +
    (djstripeCreated == null ? 0 : djstripeCreated.hashCode) +
    (djstripeUpdated == null ? 0 : djstripeUpdated.hashCode) +
    (id == null ? 0 : id.hashCode) +
    (livemode == null ? 0 : livemode.hashCode) +
    (created == null ? 0 : created.hashCode) +
    (metadata == null ? 0 : metadata.hashCode) +
    (description == null ? 0 : description.hashCode) +
    (applicationFeePercent == null ? 0 : applicationFeePercent.hashCode) +
    (billingCycleAnchor == null ? 0 : billingCycleAnchor.hashCode) +
    (billingThresholds == null ? 0 : billingThresholds.hashCode) +
    (cancelAt == null ? 0 : cancelAt.hashCode) +
    (cancelAtPeriodEnd == null ? 0 : cancelAtPeriodEnd.hashCode) +
    (canceledAt == null ? 0 : canceledAt.hashCode) +
    (collectionMethod == null ? 0 : collectionMethod.hashCode) +
    (currentPeriodEnd == null ? 0 : currentPeriodEnd.hashCode) +
    (currentPeriodStart == null ? 0 : currentPeriodStart.hashCode) +
    (daysUntilDue == null ? 0 : daysUntilDue.hashCode) +
    (discount == null ? 0 : discount.hashCode) +
    (endedAt == null ? 0 : endedAt.hashCode) +
    (nextPendingInvoiceItemInvoice == null ? 0 : nextPendingInvoiceItemInvoice.hashCode) +
    (pendingInvoiceItemInterval == null ? 0 : pendingInvoiceItemInterval.hashCode) +
    (pendingUpdate == null ? 0 : pendingUpdate.hashCode) +
    (quantity == null ? 0 : quantity.hashCode) +
    (startDate == null ? 0 : startDate.hashCode) +
    (status == null ? 0 : status.hashCode) +
    (trialEnd == null ? 0 : trialEnd.hashCode) +
    (trialStart == null ? 0 : trialStart.hashCode) +
    (djstripeOwnerAccount == null ? 0 : djstripeOwnerAccount.hashCode) +
    (customer == null ? 0 : customer.hashCode) +
    (defaultPaymentMethod == null ? 0 : defaultPaymentMethod.hashCode) +
    (defaultSource == null ? 0 : defaultSource.hashCode) +
    (pendingSetupIntent == null ? 0 : pendingSetupIntent.hashCode) +
    (plan == null ? 0 : plan.hashCode) +
    (schedule == null ? 0 : schedule.hashCode) +
    (defaultTaxRates == null ? 0 : defaultTaxRates.hashCode);

  @override
  String toString() => 'StripeSubscription[djstripeId=$djstripeId, djstripeCreated=$djstripeCreated, djstripeUpdated=$djstripeUpdated, id=$id, livemode=$livemode, created=$created, metadata=$metadata, description=$description, applicationFeePercent=$applicationFeePercent, billingCycleAnchor=$billingCycleAnchor, billingThresholds=$billingThresholds, cancelAt=$cancelAt, cancelAtPeriodEnd=$cancelAtPeriodEnd, canceledAt=$canceledAt, collectionMethod=$collectionMethod, currentPeriodEnd=$currentPeriodEnd, currentPeriodStart=$currentPeriodStart, daysUntilDue=$daysUntilDue, discount=$discount, endedAt=$endedAt, nextPendingInvoiceItemInvoice=$nextPendingInvoiceItemInvoice, pendingInvoiceItemInterval=$pendingInvoiceItemInterval, pendingUpdate=$pendingUpdate, quantity=$quantity, startDate=$startDate, status=$status, trialEnd=$trialEnd, trialStart=$trialStart, djstripeOwnerAccount=$djstripeOwnerAccount, customer=$customer, defaultPaymentMethod=$defaultPaymentMethod, defaultSource=$defaultSource, pendingSetupIntent=$pendingSetupIntent, plan=$plan, schedule=$schedule, defaultTaxRates=$defaultTaxRates]';

  Map<String, dynamic> toJson() {
    final json = <String, dynamic>{};
      json[r'djstripe_id'] = djstripeId;
      json[r'djstripe_created'] = djstripeCreated.toUtc().toIso8601String();
      json[r'djstripe_updated'] = djstripeUpdated.toUtc().toIso8601String();
      json[r'id'] = id;
    if (livemode != null) {
      json[r'livemode'] = livemode;
    }
    if (created != null) {
      json[r'created'] = created.toUtc().toIso8601String();
    }
    if (metadata != null) {
      json[r'metadata'] = metadata;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (applicationFeePercent != null) {
      json[r'application_fee_percent'] = applicationFeePercent;
    }
    if (billingCycleAnchor != null) {
      json[r'billing_cycle_anchor'] = billingCycleAnchor.toUtc().toIso8601String();
    }
    if (billingThresholds != null) {
      json[r'billing_thresholds'] = billingThresholds;
    }
    if (cancelAt != null) {
      json[r'cancel_at'] = cancelAt.toUtc().toIso8601String();
    }
    if (cancelAtPeriodEnd != null) {
      json[r'cancel_at_period_end'] = cancelAtPeriodEnd;
    }
    if (canceledAt != null) {
      json[r'canceled_at'] = canceledAt.toUtc().toIso8601String();
    }
      json[r'collection_method'] = collectionMethod == null ? null : collectionMethod;
      json[r'current_period_end'] = currentPeriodEnd.toUtc().toIso8601String();
      json[r'current_period_start'] = currentPeriodStart.toUtc().toIso8601String();
    if (daysUntilDue != null) {
      json[r'days_until_due'] = daysUntilDue;
    }
    if (discount != null) {
      json[r'discount'] = discount;
    }
    if (endedAt != null) {
      json[r'ended_at'] = endedAt.toUtc().toIso8601String();
    }
    if (nextPendingInvoiceItemInvoice != null) {
      json[r'next_pending_invoice_item_invoice'] = nextPendingInvoiceItemInvoice.toUtc().toIso8601String();
    }
    if (pendingInvoiceItemInterval != null) {
      json[r'pending_invoice_item_interval'] = pendingInvoiceItemInterval;
    }
    if (pendingUpdate != null) {
      json[r'pending_update'] = pendingUpdate;
    }
    if (quantity != null) {
      json[r'quantity'] = quantity;
    }
    if (startDate != null) {
      json[r'start_date'] = startDate.toUtc().toIso8601String();
    }
      json[r'status'] = status == null ? null : status;
    if (trialEnd != null) {
      json[r'trial_end'] = trialEnd.toUtc().toIso8601String();
    }
    if (trialStart != null) {
      json[r'trial_start'] = trialStart.toUtc().toIso8601String();
    }
      json[r'djstripe_owner_account'] = djstripeOwnerAccount == null ? null : djstripeOwnerAccount;
      json[r'customer'] = customer == null ? null : customer;
      json[r'default_payment_method'] = defaultPaymentMethod == null ? null : defaultPaymentMethod;
      json[r'default_source'] = defaultSource == null ? null : defaultSource;
      json[r'pending_setup_intent'] = pendingSetupIntent == null ? null : pendingSetupIntent;
      json[r'plan'] = plan == null ? null : plan;
      json[r'schedule'] = schedule == null ? null : schedule;
      json[r'default_tax_rates'] = defaultTaxRates;
    return json;
  }

  /// Returns a new [StripeSubscription] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static StripeSubscription fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();
      return StripeSubscription(
        djstripeId: mapValueOfType<int>(json, r'djstripe_id'),
        djstripeCreated: mapDateTime(json, r'djstripe_created', ''),
        djstripeUpdated: mapDateTime(json, r'djstripe_updated', ''),
        id: mapValueOfType<String>(json, r'id'),
        livemode: mapValueOfType<bool>(json, r'livemode'),
        created: mapDateTime(json, r'created', ''),
        metadata: mapValueOfType<Map<String, Object>>(json, r'metadata'),
        description: mapValueOfType<String>(json, r'description'),
        applicationFeePercent: mapValueOfType<double>(json, r'application_fee_percent'),
        billingCycleAnchor: mapDateTime(json, r'billing_cycle_anchor', ''),
        billingThresholds: mapValueOfType<Map<String, Object>>(json, r'billing_thresholds'),
        cancelAt: mapDateTime(json, r'cancel_at', ''),
        cancelAtPeriodEnd: mapValueOfType<bool>(json, r'cancel_at_period_end'),
        canceledAt: mapDateTime(json, r'canceled_at', ''),
        collectionMethod: CollectionMethodEnum.fromJson(json[r'collection_method']),
        currentPeriodEnd: mapDateTime(json, r'current_period_end', ''),
        currentPeriodStart: mapDateTime(json, r'current_period_start', ''),
        daysUntilDue: mapValueOfType<int>(json, r'days_until_due'),
        discount: mapValueOfType<Map<String, Object>>(json, r'discount'),
        endedAt: mapDateTime(json, r'ended_at', ''),
        nextPendingInvoiceItemInvoice: mapDateTime(json, r'next_pending_invoice_item_invoice', ''),
        pendingInvoiceItemInterval: mapValueOfType<Map<String, Object>>(json, r'pending_invoice_item_interval'),
        pendingUpdate: mapValueOfType<Map<String, Object>>(json, r'pending_update'),
        quantity: mapValueOfType<int>(json, r'quantity'),
        startDate: mapDateTime(json, r'start_date', ''),
        status: StripeSubscriptionStatusEnum.fromJson(json[r'status']),
        trialEnd: mapDateTime(json, r'trial_end', ''),
        trialStart: mapDateTime(json, r'trial_start', ''),
        djstripeOwnerAccount: Nested.fromJson(json[r'djstripe_owner_account']),
        customer: Nested.fromJson(json[r'customer']),
        defaultPaymentMethod: Nested.fromJson(json[r'default_payment_method']),
        defaultSource: Nested.fromJson(json[r'default_source']),
        pendingSetupIntent: Nested.fromJson(json[r'pending_setup_intent']),
        plan: Nested.fromJson(json[r'plan']),
        schedule: Nested.fromJson(json[r'schedule']),
        defaultTaxRates: Nested.listFromJson(json[r'default_tax_rates']),
      );
    }
    return null;
  }

  static List<StripeSubscription> listFromJson(dynamic json, {bool emptyIsNull, bool growable,}) =>
    json is List && json.isNotEmpty
      ? json.map(StripeSubscription.fromJson).toList(growable: true == growable)
      : true == emptyIsNull ? null : <StripeSubscription>[];

  static Map<String, StripeSubscription> mapFromJson(dynamic json) {
    final map = <String, StripeSubscription>{};
    if (json is Map && json.isNotEmpty) {
      json
        .cast<String, dynamic>()
        .forEach((key, dynamic value) => map[key] = StripeSubscription.fromJson(value));
    }
    return map;
  }

  // maps a json object with a list of StripeSubscription-objects as value to a dart map
  static Map<String, List<StripeSubscription>> mapListFromJson(dynamic json, {bool emptyIsNull, bool growable,}) {
    final map = <String, List<StripeSubscription>>{};
    if (json is Map && json.isNotEmpty) {
      json
        .cast<String, dynamic>()
        .forEach((key, dynamic value) {
          map[key] = StripeSubscription.listFromJson(
            value,
            emptyIsNull: emptyIsNull,
            growable: growable,
          );
        });
    }
    return map;
  }
}

