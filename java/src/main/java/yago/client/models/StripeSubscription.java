/*
 * Genie API
 * Augemented Reality Made Easy.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: hello@genie-ar.ch
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package yago.client.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;
import org.threeten.bp.OffsetDateTime;
import yago.client.models.CollectionMethodEnum;
import yago.client.models.Nested;
import yago.client.models.StripeSubscriptionStatusEnum;

/**
 * StripeSubscription
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-02-21T17:02:29.236455048+01:00[Europe/Zurich]")
public class StripeSubscription {
  public static final String SERIALIZED_NAME_DJSTRIPE_ID = "djstripe_id";
  @SerializedName(SERIALIZED_NAME_DJSTRIPE_ID)
  private Integer djstripeId;

  public static final String SERIALIZED_NAME_DJSTRIPE_CREATED = "djstripe_created";
  @SerializedName(SERIALIZED_NAME_DJSTRIPE_CREATED)
  private OffsetDateTime djstripeCreated;

  public static final String SERIALIZED_NAME_DJSTRIPE_UPDATED = "djstripe_updated";
  @SerializedName(SERIALIZED_NAME_DJSTRIPE_UPDATED)
  private OffsetDateTime djstripeUpdated;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_LIVEMODE = "livemode";
  @SerializedName(SERIALIZED_NAME_LIVEMODE)
  private Boolean livemode;

  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private OffsetDateTime created;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, Object> metadata = null;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_APPLICATION_FEE_PERCENT = "application_fee_percent";
  @SerializedName(SERIALIZED_NAME_APPLICATION_FEE_PERCENT)
  private BigDecimal applicationFeePercent;

  public static final String SERIALIZED_NAME_BILLING_CYCLE_ANCHOR = "billing_cycle_anchor";
  @SerializedName(SERIALIZED_NAME_BILLING_CYCLE_ANCHOR)
  private OffsetDateTime billingCycleAnchor;

  public static final String SERIALIZED_NAME_BILLING_THRESHOLDS = "billing_thresholds";
  @SerializedName(SERIALIZED_NAME_BILLING_THRESHOLDS)
  private Map<String, Object> billingThresholds = null;

  public static final String SERIALIZED_NAME_CANCEL_AT = "cancel_at";
  @SerializedName(SERIALIZED_NAME_CANCEL_AT)
  private OffsetDateTime cancelAt;

  public static final String SERIALIZED_NAME_CANCEL_AT_PERIOD_END = "cancel_at_period_end";
  @SerializedName(SERIALIZED_NAME_CANCEL_AT_PERIOD_END)
  private Boolean cancelAtPeriodEnd;

  public static final String SERIALIZED_NAME_CANCELED_AT = "canceled_at";
  @SerializedName(SERIALIZED_NAME_CANCELED_AT)
  private OffsetDateTime canceledAt;

  public static final String SERIALIZED_NAME_COLLECTION_METHOD = "collection_method";
  @SerializedName(SERIALIZED_NAME_COLLECTION_METHOD)
  private CollectionMethodEnum collectionMethod;

  public static final String SERIALIZED_NAME_CURRENT_PERIOD_END = "current_period_end";
  @SerializedName(SERIALIZED_NAME_CURRENT_PERIOD_END)
  private OffsetDateTime currentPeriodEnd;

  public static final String SERIALIZED_NAME_CURRENT_PERIOD_START = "current_period_start";
  @SerializedName(SERIALIZED_NAME_CURRENT_PERIOD_START)
  private OffsetDateTime currentPeriodStart;

  public static final String SERIALIZED_NAME_DAYS_UNTIL_DUE = "days_until_due";
  @SerializedName(SERIALIZED_NAME_DAYS_UNTIL_DUE)
  private Integer daysUntilDue;

  public static final String SERIALIZED_NAME_DISCOUNT = "discount";
  @SerializedName(SERIALIZED_NAME_DISCOUNT)
  private Map<String, Object> discount = null;

  public static final String SERIALIZED_NAME_ENDED_AT = "ended_at";
  @SerializedName(SERIALIZED_NAME_ENDED_AT)
  private OffsetDateTime endedAt;

  public static final String SERIALIZED_NAME_NEXT_PENDING_INVOICE_ITEM_INVOICE = "next_pending_invoice_item_invoice";
  @SerializedName(SERIALIZED_NAME_NEXT_PENDING_INVOICE_ITEM_INVOICE)
  private OffsetDateTime nextPendingInvoiceItemInvoice;

  public static final String SERIALIZED_NAME_PENDING_INVOICE_ITEM_INTERVAL = "pending_invoice_item_interval";
  @SerializedName(SERIALIZED_NAME_PENDING_INVOICE_ITEM_INTERVAL)
  private Map<String, Object> pendingInvoiceItemInterval = null;

  public static final String SERIALIZED_NAME_PENDING_UPDATE = "pending_update";
  @SerializedName(SERIALIZED_NAME_PENDING_UPDATE)
  private Map<String, Object> pendingUpdate = null;

  public static final String SERIALIZED_NAME_QUANTITY = "quantity";
  @SerializedName(SERIALIZED_NAME_QUANTITY)
  private Integer quantity;

  public static final String SERIALIZED_NAME_START_DATE = "start_date";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StripeSubscriptionStatusEnum status;

  public static final String SERIALIZED_NAME_TRIAL_END = "trial_end";
  @SerializedName(SERIALIZED_NAME_TRIAL_END)
  private OffsetDateTime trialEnd;

  public static final String SERIALIZED_NAME_TRIAL_START = "trial_start";
  @SerializedName(SERIALIZED_NAME_TRIAL_START)
  private OffsetDateTime trialStart;

  public static final String SERIALIZED_NAME_DJSTRIPE_OWNER_ACCOUNT = "djstripe_owner_account";
  @SerializedName(SERIALIZED_NAME_DJSTRIPE_OWNER_ACCOUNT)
  private Nested djstripeOwnerAccount;

  public static final String SERIALIZED_NAME_CUSTOMER = "customer";
  @SerializedName(SERIALIZED_NAME_CUSTOMER)
  private Nested customer;

  public static final String SERIALIZED_NAME_DEFAULT_PAYMENT_METHOD = "default_payment_method";
  @SerializedName(SERIALIZED_NAME_DEFAULT_PAYMENT_METHOD)
  private Nested defaultPaymentMethod;

  public static final String SERIALIZED_NAME_DEFAULT_SOURCE = "default_source";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SOURCE)
  private Nested defaultSource;

  public static final String SERIALIZED_NAME_LATEST_INVOICE = "latest_invoice";
  @SerializedName(SERIALIZED_NAME_LATEST_INVOICE)
  private Nested latestInvoice;

  public static final String SERIALIZED_NAME_PENDING_SETUP_INTENT = "pending_setup_intent";
  @SerializedName(SERIALIZED_NAME_PENDING_SETUP_INTENT)
  private Nested pendingSetupIntent;

  public static final String SERIALIZED_NAME_PLAN = "plan";
  @SerializedName(SERIALIZED_NAME_PLAN)
  private Nested plan;

  public static final String SERIALIZED_NAME_SCHEDULE = "schedule";
  @SerializedName(SERIALIZED_NAME_SCHEDULE)
  private Nested schedule;

  public static final String SERIALIZED_NAME_DEFAULT_TAX_RATES = "default_tax_rates";
  @SerializedName(SERIALIZED_NAME_DEFAULT_TAX_RATES)
  private List<Nested> defaultTaxRates = new ArrayList<Nested>();

  public StripeSubscription() { 
  }

  
  public StripeSubscription(
     Integer djstripeId, 
     OffsetDateTime djstripeCreated, 
     OffsetDateTime djstripeUpdated, 
     Nested djstripeOwnerAccount, 
     Nested customer, 
     Nested defaultPaymentMethod, 
     Nested defaultSource, 
     Nested latestInvoice, 
     Nested pendingSetupIntent, 
     Nested plan, 
     Nested schedule, 
     List<Nested> defaultTaxRates
  ) {
    this();
    this.djstripeId = djstripeId;
    this.djstripeCreated = djstripeCreated;
    this.djstripeUpdated = djstripeUpdated;
    this.djstripeOwnerAccount = djstripeOwnerAccount;
    this.customer = customer;
    this.defaultPaymentMethod = defaultPaymentMethod;
    this.defaultSource = defaultSource;
    this.latestInvoice = latestInvoice;
    this.pendingSetupIntent = pendingSetupIntent;
    this.plan = plan;
    this.schedule = schedule;
    this.defaultTaxRates = defaultTaxRates;
  }

   /**
   * Get djstripeId
   * @return djstripeId
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Integer getDjstripeId() {
    return djstripeId;
  }




   /**
   * Get djstripeCreated
   * @return djstripeCreated
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public OffsetDateTime getDjstripeCreated() {
    return djstripeCreated;
  }




   /**
   * Get djstripeUpdated
   * @return djstripeUpdated
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public OffsetDateTime getDjstripeUpdated() {
    return djstripeUpdated;
  }




  public StripeSubscription id(String id) {
    
    this.id = id;
    return this;
  }

   /**
   * Get id
   * @return id
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public String getId() {
    return id;
  }


  public void setId(String id) {
    this.id = id;
  }


  public StripeSubscription livemode(Boolean livemode) {
    
    this.livemode = livemode;
    return this;
  }

   /**
   * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
   * @return livemode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.")

  public Boolean getLivemode() {
    return livemode;
  }


  public void setLivemode(Boolean livemode) {
    this.livemode = livemode;
  }


  public StripeSubscription created(OffsetDateTime created) {
    
    this.created = created;
    return this;
  }

   /**
   * The datetime this object was created in stripe.
   * @return created
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The datetime this object was created in stripe.")

  public OffsetDateTime getCreated() {
    return created;
  }


  public void setCreated(OffsetDateTime created) {
    this.created = created;
  }


  public StripeSubscription metadata(Map<String, Object> metadata) {
    
    this.metadata = metadata;
    return this;
  }

  public StripeSubscription putMetadataItem(String key, Object metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<String, Object>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

   /**
   * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
   * @return metadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.")

  public Map<String, Object> getMetadata() {
    return metadata;
  }


  public void setMetadata(Map<String, Object> metadata) {
    this.metadata = metadata;
  }


  public StripeSubscription description(String description) {
    
    this.description = description;
    return this;
  }

   /**
   * A description of this object.
   * @return description
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A description of this object.")

  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    this.description = description;
  }


  public StripeSubscription applicationFeePercent(BigDecimal applicationFeePercent) {
    
    this.applicationFeePercent = applicationFeePercent;
    return this;
  }

   /**
   * A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner&#39;s Stripe account each billing period.
   * @return applicationFeePercent
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner's Stripe account each billing period.")

  public BigDecimal getApplicationFeePercent() {
    return applicationFeePercent;
  }


  public void setApplicationFeePercent(BigDecimal applicationFeePercent) {
    this.applicationFeePercent = applicationFeePercent;
  }


  public StripeSubscription billingCycleAnchor(OffsetDateTime billingCycleAnchor) {
    
    this.billingCycleAnchor = billingCycleAnchor;
    return this;
  }

   /**
   * Determines the date of the first full invoice, and, for plans with &#x60;month&#x60; or &#x60;year&#x60; intervals, the day of the month for subsequent invoices.
   * @return billingCycleAnchor
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices.")

  public OffsetDateTime getBillingCycleAnchor() {
    return billingCycleAnchor;
  }


  public void setBillingCycleAnchor(OffsetDateTime billingCycleAnchor) {
    this.billingCycleAnchor = billingCycleAnchor;
  }


  public StripeSubscription billingThresholds(Map<String, Object> billingThresholds) {
    
    this.billingThresholds = billingThresholds;
    return this;
  }

  public StripeSubscription putBillingThresholdsItem(String key, Object billingThresholdsItem) {
    if (this.billingThresholds == null) {
      this.billingThresholds = new HashMap<String, Object>();
    }
    this.billingThresholds.put(key, billingThresholdsItem);
    return this;
  }

   /**
   * Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.
   * @return billingThresholds
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.")

  public Map<String, Object> getBillingThresholds() {
    return billingThresholds;
  }


  public void setBillingThresholds(Map<String, Object> billingThresholds) {
    this.billingThresholds = billingThresholds;
  }


  public StripeSubscription cancelAt(OffsetDateTime cancelAt) {
    
    this.cancelAt = cancelAt;
    return this;
  }

   /**
   * A date in the future at which the subscription will automatically get canceled.
   * @return cancelAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A date in the future at which the subscription will automatically get canceled.")

  public OffsetDateTime getCancelAt() {
    return cancelAt;
  }


  public void setCancelAt(OffsetDateTime cancelAt) {
    this.cancelAt = cancelAt;
  }


  public StripeSubscription cancelAtPeriodEnd(Boolean cancelAtPeriodEnd) {
    
    this.cancelAtPeriodEnd = cancelAtPeriodEnd;
    return this;
  }

   /**
   * If the subscription has been canceled with the &#x60;&#x60;at_period_end&#x60;&#x60; flag set to true, &#x60;&#x60;cancel_at_period_end&#x60;&#x60; on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
   * @return cancelAtPeriodEnd
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If the subscription has been canceled with the ``at_period_end`` flag set to true, ``cancel_at_period_end`` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.")

  public Boolean getCancelAtPeriodEnd() {
    return cancelAtPeriodEnd;
  }


  public void setCancelAtPeriodEnd(Boolean cancelAtPeriodEnd) {
    this.cancelAtPeriodEnd = cancelAtPeriodEnd;
  }


  public StripeSubscription canceledAt(OffsetDateTime canceledAt) {
    
    this.canceledAt = canceledAt;
    return this;
  }

   /**
   * If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with &#x60;&#x60;cancel_at_period_end&#x60;&#x60;, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
   * @return canceledAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with ``cancel_at_period_end``, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.")

  public OffsetDateTime getCanceledAt() {
    return canceledAt;
  }


  public void setCanceledAt(OffsetDateTime canceledAt) {
    this.canceledAt = canceledAt;
  }


  public StripeSubscription collectionMethod(CollectionMethodEnum collectionMethod) {
    
    this.collectionMethod = collectionMethod;
    return this;
  }

   /**
   * Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
   * @return collectionMethod
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.")

  public CollectionMethodEnum getCollectionMethod() {
    return collectionMethod;
  }


  public void setCollectionMethod(CollectionMethodEnum collectionMethod) {
    this.collectionMethod = collectionMethod;
  }


  public StripeSubscription currentPeriodEnd(OffsetDateTime currentPeriodEnd) {
    
    this.currentPeriodEnd = currentPeriodEnd;
    return this;
  }

   /**
   * End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.
   * @return currentPeriodEnd
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.")

  public OffsetDateTime getCurrentPeriodEnd() {
    return currentPeriodEnd;
  }


  public void setCurrentPeriodEnd(OffsetDateTime currentPeriodEnd) {
    this.currentPeriodEnd = currentPeriodEnd;
  }


  public StripeSubscription currentPeriodStart(OffsetDateTime currentPeriodStart) {
    
    this.currentPeriodStart = currentPeriodStart;
    return this;
  }

   /**
   * Start of the current period for which the subscription has been invoiced.
   * @return currentPeriodStart
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Start of the current period for which the subscription has been invoiced.")

  public OffsetDateTime getCurrentPeriodStart() {
    return currentPeriodStart;
  }


  public void setCurrentPeriodStart(OffsetDateTime currentPeriodStart) {
    this.currentPeriodStart = currentPeriodStart;
  }


  public StripeSubscription daysUntilDue(Integer daysUntilDue) {
    
    this.daysUntilDue = daysUntilDue;
    return this;
  }

   /**
   * Number of days a customer has to pay invoices generated by this subscription. This value will be &#x60;null&#x60; for subscriptions where &#x60;billing&#x3D;charge_automatically&#x60;.
   * minimum: -2147483648
   * maximum: 2147483647
   * @return daysUntilDue
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Number of days a customer has to pay invoices generated by this subscription. This value will be `null` for subscriptions where `billing=charge_automatically`.")

  public Integer getDaysUntilDue() {
    return daysUntilDue;
  }


  public void setDaysUntilDue(Integer daysUntilDue) {
    this.daysUntilDue = daysUntilDue;
  }


  public StripeSubscription discount(Map<String, Object> discount) {
    
    this.discount = discount;
    return this;
  }

  public StripeSubscription putDiscountItem(String key, Object discountItem) {
    if (this.discount == null) {
      this.discount = new HashMap<String, Object>();
    }
    this.discount.put(key, discountItem);
    return this;
  }

   /**
   * Get discount
   * @return discount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Map<String, Object> getDiscount() {
    return discount;
  }


  public void setDiscount(Map<String, Object> discount) {
    this.discount = discount;
  }


  public StripeSubscription endedAt(OffsetDateTime endedAt) {
    
    this.endedAt = endedAt;
    return this;
  }

   /**
   * If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.
   * @return endedAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.")

  public OffsetDateTime getEndedAt() {
    return endedAt;
  }


  public void setEndedAt(OffsetDateTime endedAt) {
    this.endedAt = endedAt;
  }


  public StripeSubscription nextPendingInvoiceItemInvoice(OffsetDateTime nextPendingInvoiceItemInvoice) {
    
    this.nextPendingInvoiceItemInvoice = nextPendingInvoiceItemInvoice;
    return this;
  }

   /**
   * Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval.
   * @return nextPendingInvoiceItemInvoice
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval.")

  public OffsetDateTime getNextPendingInvoiceItemInvoice() {
    return nextPendingInvoiceItemInvoice;
  }


  public void setNextPendingInvoiceItemInvoice(OffsetDateTime nextPendingInvoiceItemInvoice) {
    this.nextPendingInvoiceItemInvoice = nextPendingInvoiceItemInvoice;
  }


  public StripeSubscription pendingInvoiceItemInterval(Map<String, Object> pendingInvoiceItemInterval) {
    
    this.pendingInvoiceItemInterval = pendingInvoiceItemInterval;
    return this;
  }

  public StripeSubscription putPendingInvoiceItemIntervalItem(String key, Object pendingInvoiceItemIntervalItem) {
    if (this.pendingInvoiceItemInterval == null) {
      this.pendingInvoiceItemInterval = new HashMap<String, Object>();
    }
    this.pendingInvoiceItemInterval.put(key, pendingInvoiceItemIntervalItem);
    return this;
  }

   /**
   * Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval.
   * @return pendingInvoiceItemInterval
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval.")

  public Map<String, Object> getPendingInvoiceItemInterval() {
    return pendingInvoiceItemInterval;
  }


  public void setPendingInvoiceItemInterval(Map<String, Object> pendingInvoiceItemInterval) {
    this.pendingInvoiceItemInterval = pendingInvoiceItemInterval;
  }


  public StripeSubscription pendingUpdate(Map<String, Object> pendingUpdate) {
    
    this.pendingUpdate = pendingUpdate;
    return this;
  }

  public StripeSubscription putPendingUpdateItem(String key, Object pendingUpdateItem) {
    if (this.pendingUpdate == null) {
      this.pendingUpdate = new HashMap<String, Object>();
    }
    this.pendingUpdate.put(key, pendingUpdateItem);
    return this;
  }

   /**
   * If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.
   * @return pendingUpdate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.")

  public Map<String, Object> getPendingUpdate() {
    return pendingUpdate;
  }


  public void setPendingUpdate(Map<String, Object> pendingUpdate) {
    this.pendingUpdate = pendingUpdate;
  }


  public StripeSubscription quantity(Integer quantity) {
    
    this.quantity = quantity;
    return this;
  }

   /**
   * The quantity applied to this subscription. This value will be &#x60;null&#x60; for multi-plan subscriptions
   * minimum: -2147483648
   * maximum: 2147483647
   * @return quantity
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The quantity applied to this subscription. This value will be `null` for multi-plan subscriptions")

  public Integer getQuantity() {
    return quantity;
  }


  public void setQuantity(Integer quantity) {
    this.quantity = quantity;
  }


  public StripeSubscription startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * Date when the subscription was first created. The date might differ from the created date due to backdating.
   * @return startDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Date when the subscription was first created. The date might differ from the created date due to backdating.")

  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public StripeSubscription status(StripeSubscriptionStatusEnum status) {
    
    this.status = status;
    return this;
  }

   /**
   * The status of this subscription.
   * @return status
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "The status of this subscription.")

  public StripeSubscriptionStatusEnum getStatus() {
    return status;
  }


  public void setStatus(StripeSubscriptionStatusEnum status) {
    this.status = status;
  }


  public StripeSubscription trialEnd(OffsetDateTime trialEnd) {
    
    this.trialEnd = trialEnd;
    return this;
  }

   /**
   * If the subscription has a trial, the end of that trial.
   * @return trialEnd
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If the subscription has a trial, the end of that trial.")

  public OffsetDateTime getTrialEnd() {
    return trialEnd;
  }


  public void setTrialEnd(OffsetDateTime trialEnd) {
    this.trialEnd = trialEnd;
  }


  public StripeSubscription trialStart(OffsetDateTime trialStart) {
    
    this.trialStart = trialStart;
    return this;
  }

   /**
   * If the subscription has a trial, the beginning of that trial.
   * @return trialStart
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If the subscription has a trial, the beginning of that trial.")

  public OffsetDateTime getTrialStart() {
    return trialStart;
  }


  public void setTrialStart(OffsetDateTime trialStart) {
    this.trialStart = trialStart;
  }


   /**
   * Get djstripeOwnerAccount
   * @return djstripeOwnerAccount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Nested getDjstripeOwnerAccount() {
    return djstripeOwnerAccount;
  }




   /**
   * Get customer
   * @return customer
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Nested getCustomer() {
    return customer;
  }




   /**
   * Get defaultPaymentMethod
   * @return defaultPaymentMethod
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Nested getDefaultPaymentMethod() {
    return defaultPaymentMethod;
  }




   /**
   * Get defaultSource
   * @return defaultSource
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Nested getDefaultSource() {
    return defaultSource;
  }




   /**
   * Get latestInvoice
   * @return latestInvoice
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Nested getLatestInvoice() {
    return latestInvoice;
  }




   /**
   * Get pendingSetupIntent
   * @return pendingSetupIntent
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Nested getPendingSetupIntent() {
    return pendingSetupIntent;
  }




   /**
   * Get plan
   * @return plan
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Nested getPlan() {
    return plan;
  }




   /**
   * Get schedule
   * @return schedule
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(required = true, value = "")

  public Nested getSchedule() {
    return schedule;
  }




   /**
   * Get defaultTaxRates
   * @return defaultTaxRates
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public List<Nested> getDefaultTaxRates() {
    return defaultTaxRates;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StripeSubscription stripeSubscription = (StripeSubscription) o;
    return Objects.equals(this.djstripeId, stripeSubscription.djstripeId) &&
        Objects.equals(this.djstripeCreated, stripeSubscription.djstripeCreated) &&
        Objects.equals(this.djstripeUpdated, stripeSubscription.djstripeUpdated) &&
        Objects.equals(this.id, stripeSubscription.id) &&
        Objects.equals(this.livemode, stripeSubscription.livemode) &&
        Objects.equals(this.created, stripeSubscription.created) &&
        Objects.equals(this.metadata, stripeSubscription.metadata) &&
        Objects.equals(this.description, stripeSubscription.description) &&
        Objects.equals(this.applicationFeePercent, stripeSubscription.applicationFeePercent) &&
        Objects.equals(this.billingCycleAnchor, stripeSubscription.billingCycleAnchor) &&
        Objects.equals(this.billingThresholds, stripeSubscription.billingThresholds) &&
        Objects.equals(this.cancelAt, stripeSubscription.cancelAt) &&
        Objects.equals(this.cancelAtPeriodEnd, stripeSubscription.cancelAtPeriodEnd) &&
        Objects.equals(this.canceledAt, stripeSubscription.canceledAt) &&
        Objects.equals(this.collectionMethod, stripeSubscription.collectionMethod) &&
        Objects.equals(this.currentPeriodEnd, stripeSubscription.currentPeriodEnd) &&
        Objects.equals(this.currentPeriodStart, stripeSubscription.currentPeriodStart) &&
        Objects.equals(this.daysUntilDue, stripeSubscription.daysUntilDue) &&
        Objects.equals(this.discount, stripeSubscription.discount) &&
        Objects.equals(this.endedAt, stripeSubscription.endedAt) &&
        Objects.equals(this.nextPendingInvoiceItemInvoice, stripeSubscription.nextPendingInvoiceItemInvoice) &&
        Objects.equals(this.pendingInvoiceItemInterval, stripeSubscription.pendingInvoiceItemInterval) &&
        Objects.equals(this.pendingUpdate, stripeSubscription.pendingUpdate) &&
        Objects.equals(this.quantity, stripeSubscription.quantity) &&
        Objects.equals(this.startDate, stripeSubscription.startDate) &&
        Objects.equals(this.status, stripeSubscription.status) &&
        Objects.equals(this.trialEnd, stripeSubscription.trialEnd) &&
        Objects.equals(this.trialStart, stripeSubscription.trialStart) &&
        Objects.equals(this.djstripeOwnerAccount, stripeSubscription.djstripeOwnerAccount) &&
        Objects.equals(this.customer, stripeSubscription.customer) &&
        Objects.equals(this.defaultPaymentMethod, stripeSubscription.defaultPaymentMethod) &&
        Objects.equals(this.defaultSource, stripeSubscription.defaultSource) &&
        Objects.equals(this.latestInvoice, stripeSubscription.latestInvoice) &&
        Objects.equals(this.pendingSetupIntent, stripeSubscription.pendingSetupIntent) &&
        Objects.equals(this.plan, stripeSubscription.plan) &&
        Objects.equals(this.schedule, stripeSubscription.schedule) &&
        Objects.equals(this.defaultTaxRates, stripeSubscription.defaultTaxRates);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(djstripeId, djstripeCreated, djstripeUpdated, id, livemode, created, metadata, description, applicationFeePercent, billingCycleAnchor, billingThresholds, cancelAt, cancelAtPeriodEnd, canceledAt, collectionMethod, currentPeriodEnd, currentPeriodStart, daysUntilDue, discount, endedAt, nextPendingInvoiceItemInvoice, pendingInvoiceItemInterval, pendingUpdate, quantity, startDate, status, trialEnd, trialStart, djstripeOwnerAccount, customer, defaultPaymentMethod, defaultSource, latestInvoice, pendingSetupIntent, plan, schedule, defaultTaxRates);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StripeSubscription {\n");
    sb.append("    djstripeId: ").append(toIndentedString(djstripeId)).append("\n");
    sb.append("    djstripeCreated: ").append(toIndentedString(djstripeCreated)).append("\n");
    sb.append("    djstripeUpdated: ").append(toIndentedString(djstripeUpdated)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    livemode: ").append(toIndentedString(livemode)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    applicationFeePercent: ").append(toIndentedString(applicationFeePercent)).append("\n");
    sb.append("    billingCycleAnchor: ").append(toIndentedString(billingCycleAnchor)).append("\n");
    sb.append("    billingThresholds: ").append(toIndentedString(billingThresholds)).append("\n");
    sb.append("    cancelAt: ").append(toIndentedString(cancelAt)).append("\n");
    sb.append("    cancelAtPeriodEnd: ").append(toIndentedString(cancelAtPeriodEnd)).append("\n");
    sb.append("    canceledAt: ").append(toIndentedString(canceledAt)).append("\n");
    sb.append("    collectionMethod: ").append(toIndentedString(collectionMethod)).append("\n");
    sb.append("    currentPeriodEnd: ").append(toIndentedString(currentPeriodEnd)).append("\n");
    sb.append("    currentPeriodStart: ").append(toIndentedString(currentPeriodStart)).append("\n");
    sb.append("    daysUntilDue: ").append(toIndentedString(daysUntilDue)).append("\n");
    sb.append("    discount: ").append(toIndentedString(discount)).append("\n");
    sb.append("    endedAt: ").append(toIndentedString(endedAt)).append("\n");
    sb.append("    nextPendingInvoiceItemInvoice: ").append(toIndentedString(nextPendingInvoiceItemInvoice)).append("\n");
    sb.append("    pendingInvoiceItemInterval: ").append(toIndentedString(pendingInvoiceItemInterval)).append("\n");
    sb.append("    pendingUpdate: ").append(toIndentedString(pendingUpdate)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    trialEnd: ").append(toIndentedString(trialEnd)).append("\n");
    sb.append("    trialStart: ").append(toIndentedString(trialStart)).append("\n");
    sb.append("    djstripeOwnerAccount: ").append(toIndentedString(djstripeOwnerAccount)).append("\n");
    sb.append("    customer: ").append(toIndentedString(customer)).append("\n");
    sb.append("    defaultPaymentMethod: ").append(toIndentedString(defaultPaymentMethod)).append("\n");
    sb.append("    defaultSource: ").append(toIndentedString(defaultSource)).append("\n");
    sb.append("    latestInvoice: ").append(toIndentedString(latestInvoice)).append("\n");
    sb.append("    pendingSetupIntent: ").append(toIndentedString(pendingSetupIntent)).append("\n");
    sb.append("    plan: ").append(toIndentedString(plan)).append("\n");
    sb.append("    schedule: ").append(toIndentedString(schedule)).append("\n");
    sb.append("    defaultTaxRates: ").append(toIndentedString(defaultTaxRates)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

