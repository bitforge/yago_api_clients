/*
 * Genie API
 *
 * Augemented Reality Made Easy.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: hello@genie-ar.ch
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Genie.Api.Client.OpenAPIDateConverter;

namespace Genie.Api.Model
{
    /// <summary>
    /// StripeSubscription
    /// </summary>
    [DataContract(Name = "StripeSubscription")]
    public partial class StripeSubscription : IEquatable<StripeSubscription>, IValidatableObject
    {

        /// <summary>
        /// Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.
        /// </summary>
        /// <value>Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions.</value>
        [DataMember(Name = "collection_method", IsRequired = true, EmitDefaultValue = true)]
        public CollectionMethodEnum CollectionMethod { get; set; }

        /// <summary>
        /// The status of this subscription.
        /// </summary>
        /// <value>The status of this subscription.</value>
        [DataMember(Name = "status", IsRequired = true, EmitDefaultValue = true)]
        public StripeSubscriptionStatusEnum Status { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="StripeSubscription" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected StripeSubscription() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="StripeSubscription" /> class.
        /// </summary>
        /// <param name="id">id (required).</param>
        /// <param name="livemode">Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation..</param>
        /// <param name="created">The datetime this object was created in stripe..</param>
        /// <param name="metadata">A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format..</param>
        /// <param name="description">A description of this object..</param>
        /// <param name="applicationFeePercent">A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner&#39;s Stripe account each billing period..</param>
        /// <param name="billingCycleAnchor">Determines the date of the first full invoice, and, for plans with &#x60;month&#x60; or &#x60;year&#x60; intervals, the day of the month for subsequent invoices..</param>
        /// <param name="billingThresholds">Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period..</param>
        /// <param name="cancelAt">A date in the future at which the subscription will automatically get canceled..</param>
        /// <param name="cancelAtPeriodEnd">If the subscription has been canceled with the &#x60;&#x60;at_period_end&#x60;&#x60; flag set to true, &#x60;&#x60;cancel_at_period_end&#x60;&#x60; on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period..</param>
        /// <param name="canceledAt">If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with &#x60;&#x60;cancel_at_period_end&#x60;&#x60;, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state..</param>
        /// <param name="collectionMethod">Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. (required).</param>
        /// <param name="currentPeriodEnd">End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created. (required).</param>
        /// <param name="currentPeriodStart">Start of the current period for which the subscription has been invoiced. (required).</param>
        /// <param name="daysUntilDue">Number of days a customer has to pay invoices generated by this subscription. This value will be &#x60;null&#x60; for subscriptions where &#x60;billing&#x3D;charge_automatically&#x60;..</param>
        /// <param name="discount">discount.</param>
        /// <param name="endedAt">If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended..</param>
        /// <param name="nextPendingInvoiceItemInvoice">Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval..</param>
        /// <param name="pendingInvoiceItemInterval">Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval..</param>
        /// <param name="pendingUpdate">If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid..</param>
        /// <param name="quantity">The quantity applied to this subscription. This value will be &#x60;null&#x60; for multi-plan subscriptions.</param>
        /// <param name="startDate">Date when the subscription was first created. The date might differ from the created date due to backdating..</param>
        /// <param name="status">The status of this subscription. (required).</param>
        /// <param name="trialEnd">If the subscription has a trial, the end of that trial..</param>
        /// <param name="trialStart">If the subscription has a trial, the beginning of that trial..</param>
        public StripeSubscription(string id = default(string), bool? livemode = default(bool?), DateTime? created = default(DateTime?), Dictionary<string, Object> metadata = default(Dictionary<string, Object>), string description = default(string), decimal? applicationFeePercent = default(decimal?), DateTime? billingCycleAnchor = default(DateTime?), Dictionary<string, Object> billingThresholds = default(Dictionary<string, Object>), DateTime? cancelAt = default(DateTime?), bool cancelAtPeriodEnd = default(bool), DateTime? canceledAt = default(DateTime?), CollectionMethodEnum collectionMethod = default(CollectionMethodEnum), DateTime currentPeriodEnd = default(DateTime), DateTime currentPeriodStart = default(DateTime), int? daysUntilDue = default(int?), Dictionary<string, Object> discount = default(Dictionary<string, Object>), DateTime? endedAt = default(DateTime?), DateTime? nextPendingInvoiceItemInvoice = default(DateTime?), Dictionary<string, Object> pendingInvoiceItemInterval = default(Dictionary<string, Object>), Dictionary<string, Object> pendingUpdate = default(Dictionary<string, Object>), int? quantity = default(int?), DateTime? startDate = default(DateTime?), StripeSubscriptionStatusEnum status = default(StripeSubscriptionStatusEnum), DateTime? trialEnd = default(DateTime?), DateTime? trialStart = default(DateTime?))
        {
            // to ensure "id" is required (not null)
            if (id == null) {
                throw new ArgumentNullException("id is a required property for StripeSubscription and cannot be null");
            }
            this.Id = id;
            this.CollectionMethod = collectionMethod;
            this.CurrentPeriodEnd = currentPeriodEnd;
            this.CurrentPeriodStart = currentPeriodStart;
            this.Status = status;
            this.Livemode = livemode;
            this.Created = created;
            this.Metadata = metadata;
            this.Description = description;
            this.ApplicationFeePercent = applicationFeePercent;
            this.BillingCycleAnchor = billingCycleAnchor;
            this.BillingThresholds = billingThresholds;
            this.CancelAt = cancelAt;
            this.CancelAtPeriodEnd = cancelAtPeriodEnd;
            this.CanceledAt = canceledAt;
            this.DaysUntilDue = daysUntilDue;
            this.Discount = discount;
            this.EndedAt = endedAt;
            this.NextPendingInvoiceItemInvoice = nextPendingInvoiceItemInvoice;
            this.PendingInvoiceItemInterval = pendingInvoiceItemInterval;
            this.PendingUpdate = pendingUpdate;
            this.Quantity = quantity;
            this.StartDate = startDate;
            this.TrialEnd = trialEnd;
            this.TrialStart = trialStart;
        }

        /// <summary>
        /// Gets or Sets DjstripeId
        /// </summary>
        [DataMember(Name = "djstripe_id", IsRequired = true, EmitDefaultValue = false)]
        public int DjstripeId { get; private set; }

        /// <summary>
        /// Returns false as DjstripeId should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDjstripeId()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets DjstripeCreated
        /// </summary>
        [DataMember(Name = "djstripe_created", IsRequired = true, EmitDefaultValue = false)]
        public DateTime DjstripeCreated { get; private set; }

        /// <summary>
        /// Returns false as DjstripeCreated should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDjstripeCreated()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets DjstripeUpdated
        /// </summary>
        [DataMember(Name = "djstripe_updated", IsRequired = true, EmitDefaultValue = false)]
        public DateTime DjstripeUpdated { get; private set; }

        /// <summary>
        /// Returns false as DjstripeUpdated should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDjstripeUpdated()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets Id
        /// </summary>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = false)]
        public string Id { get; set; }

        /// <summary>
        /// Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
        /// </summary>
        /// <value>Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.</value>
        [DataMember(Name = "livemode", EmitDefaultValue = true)]
        public bool? Livemode { get; set; }

        /// <summary>
        /// The datetime this object was created in stripe.
        /// </summary>
        /// <value>The datetime this object was created in stripe.</value>
        [DataMember(Name = "created", EmitDefaultValue = true)]
        public DateTime? Created { get; set; }

        /// <summary>
        /// A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
        /// </summary>
        /// <value>A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.</value>
        [DataMember(Name = "metadata", EmitDefaultValue = true)]
        public Dictionary<string, Object> Metadata { get; set; }

        /// <summary>
        /// A description of this object.
        /// </summary>
        /// <value>A description of this object.</value>
        [DataMember(Name = "description", EmitDefaultValue = true)]
        public string Description { get; set; }

        /// <summary>
        /// A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner&#39;s Stripe account each billing period.
        /// </summary>
        /// <value>A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to the application owner&#39;s Stripe account each billing period.</value>
        [DataMember(Name = "application_fee_percent", EmitDefaultValue = true)]
        public decimal? ApplicationFeePercent { get; set; }

        /// <summary>
        /// Determines the date of the first full invoice, and, for plans with &#x60;month&#x60; or &#x60;year&#x60; intervals, the day of the month for subsequent invoices.
        /// </summary>
        /// <value>Determines the date of the first full invoice, and, for plans with &#x60;month&#x60; or &#x60;year&#x60; intervals, the day of the month for subsequent invoices.</value>
        [DataMember(Name = "billing_cycle_anchor", EmitDefaultValue = true)]
        public DateTime? BillingCycleAnchor { get; set; }

        /// <summary>
        /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.
        /// </summary>
        /// <value>Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.</value>
        [DataMember(Name = "billing_thresholds", EmitDefaultValue = true)]
        public Dictionary<string, Object> BillingThresholds { get; set; }

        /// <summary>
        /// A date in the future at which the subscription will automatically get canceled.
        /// </summary>
        /// <value>A date in the future at which the subscription will automatically get canceled.</value>
        [DataMember(Name = "cancel_at", EmitDefaultValue = true)]
        public DateTime? CancelAt { get; set; }

        /// <summary>
        /// If the subscription has been canceled with the &#x60;&#x60;at_period_end&#x60;&#x60; flag set to true, &#x60;&#x60;cancel_at_period_end&#x60;&#x60; on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
        /// </summary>
        /// <value>If the subscription has been canceled with the &#x60;&#x60;at_period_end&#x60;&#x60; flag set to true, &#x60;&#x60;cancel_at_period_end&#x60;&#x60; on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.</value>
        [DataMember(Name = "cancel_at_period_end", EmitDefaultValue = true)]
        public bool CancelAtPeriodEnd { get; set; }

        /// <summary>
        /// If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with &#x60;&#x60;cancel_at_period_end&#x60;&#x60;, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
        /// </summary>
        /// <value>If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with &#x60;&#x60;cancel_at_period_end&#x60;&#x60;, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.</value>
        [DataMember(Name = "canceled_at", EmitDefaultValue = true)]
        public DateTime? CanceledAt { get; set; }

        /// <summary>
        /// End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.
        /// </summary>
        /// <value>End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.</value>
        [DataMember(Name = "current_period_end", IsRequired = true, EmitDefaultValue = false)]
        public DateTime CurrentPeriodEnd { get; set; }

        /// <summary>
        /// Start of the current period for which the subscription has been invoiced.
        /// </summary>
        /// <value>Start of the current period for which the subscription has been invoiced.</value>
        [DataMember(Name = "current_period_start", IsRequired = true, EmitDefaultValue = false)]
        public DateTime CurrentPeriodStart { get; set; }

        /// <summary>
        /// Number of days a customer has to pay invoices generated by this subscription. This value will be &#x60;null&#x60; for subscriptions where &#x60;billing&#x3D;charge_automatically&#x60;.
        /// </summary>
        /// <value>Number of days a customer has to pay invoices generated by this subscription. This value will be &#x60;null&#x60; for subscriptions where &#x60;billing&#x3D;charge_automatically&#x60;.</value>
        [DataMember(Name = "days_until_due", EmitDefaultValue = true)]
        public int? DaysUntilDue { get; set; }

        /// <summary>
        /// Gets or Sets Discount
        /// </summary>
        [DataMember(Name = "discount", EmitDefaultValue = true)]
        public Dictionary<string, Object> Discount { get; set; }

        /// <summary>
        /// If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.
        /// </summary>
        /// <value>If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.</value>
        [DataMember(Name = "ended_at", EmitDefaultValue = true)]
        public DateTime? EndedAt { get; set; }

        /// <summary>
        /// Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval.
        /// </summary>
        /// <value>Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at pending_invoice_item_interval.</value>
        [DataMember(Name = "next_pending_invoice_item_invoice", EmitDefaultValue = true)]
        public DateTime? NextPendingInvoiceItemInvoice { get; set; }

        /// <summary>
        /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval.
        /// </summary>
        /// <value>Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling Create an invoice for the given subscription at the specified interval.</value>
        [DataMember(Name = "pending_invoice_item_interval", EmitDefaultValue = true)]
        public Dictionary<string, Object> PendingInvoiceItemInterval { get; set; }

        /// <summary>
        /// If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.
        /// </summary>
        /// <value>If specified, pending updates that will be applied to the subscription once the latest_invoice has been paid.</value>
        [DataMember(Name = "pending_update", EmitDefaultValue = true)]
        public Dictionary<string, Object> PendingUpdate { get; set; }

        /// <summary>
        /// The quantity applied to this subscription. This value will be &#x60;null&#x60; for multi-plan subscriptions
        /// </summary>
        /// <value>The quantity applied to this subscription. This value will be &#x60;null&#x60; for multi-plan subscriptions</value>
        [DataMember(Name = "quantity", EmitDefaultValue = true)]
        public int? Quantity { get; set; }

        /// <summary>
        /// Date when the subscription was first created. The date might differ from the created date due to backdating.
        /// </summary>
        /// <value>Date when the subscription was first created. The date might differ from the created date due to backdating.</value>
        [DataMember(Name = "start_date", EmitDefaultValue = true)]
        public DateTime? StartDate { get; set; }

        /// <summary>
        /// If the subscription has a trial, the end of that trial.
        /// </summary>
        /// <value>If the subscription has a trial, the end of that trial.</value>
        [DataMember(Name = "trial_end", EmitDefaultValue = true)]
        public DateTime? TrialEnd { get; set; }

        /// <summary>
        /// If the subscription has a trial, the beginning of that trial.
        /// </summary>
        /// <value>If the subscription has a trial, the beginning of that trial.</value>
        [DataMember(Name = "trial_start", EmitDefaultValue = true)]
        public DateTime? TrialStart { get; set; }

        /// <summary>
        /// Gets or Sets DjstripeOwnerAccount
        /// </summary>
        [DataMember(Name = "djstripe_owner_account", IsRequired = true, EmitDefaultValue = true)]
        public Nested DjstripeOwnerAccount { get; private set; }

        /// <summary>
        /// Returns false as DjstripeOwnerAccount should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDjstripeOwnerAccount()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets Customer
        /// </summary>
        [DataMember(Name = "customer", IsRequired = true, EmitDefaultValue = true)]
        public Nested Customer { get; private set; }

        /// <summary>
        /// Returns false as Customer should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeCustomer()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets DefaultPaymentMethod
        /// </summary>
        [DataMember(Name = "default_payment_method", IsRequired = true, EmitDefaultValue = true)]
        public Nested DefaultPaymentMethod { get; private set; }

        /// <summary>
        /// Returns false as DefaultPaymentMethod should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDefaultPaymentMethod()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets DefaultSource
        /// </summary>
        [DataMember(Name = "default_source", IsRequired = true, EmitDefaultValue = true)]
        public Nested DefaultSource { get; private set; }

        /// <summary>
        /// Returns false as DefaultSource should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDefaultSource()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets PendingSetupIntent
        /// </summary>
        [DataMember(Name = "pending_setup_intent", IsRequired = true, EmitDefaultValue = true)]
        public Nested PendingSetupIntent { get; private set; }

        /// <summary>
        /// Returns false as PendingSetupIntent should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializePendingSetupIntent()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets Plan
        /// </summary>
        [DataMember(Name = "plan", IsRequired = true, EmitDefaultValue = true)]
        public Nested Plan { get; private set; }

        /// <summary>
        /// Returns false as Plan should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializePlan()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets Schedule
        /// </summary>
        [DataMember(Name = "schedule", IsRequired = true, EmitDefaultValue = true)]
        public Nested Schedule { get; private set; }

        /// <summary>
        /// Returns false as Schedule should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeSchedule()
        {
            return false;
        }
        /// <summary>
        /// Gets or Sets DefaultTaxRates
        /// </summary>
        [DataMember(Name = "default_tax_rates", IsRequired = true, EmitDefaultValue = false)]
        public List<Nested> DefaultTaxRates { get; private set; }

        /// <summary>
        /// Returns false as DefaultTaxRates should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeDefaultTaxRates()
        {
            return false;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class StripeSubscription {\n");
            sb.Append("  DjstripeId: ").Append(DjstripeId).Append("\n");
            sb.Append("  DjstripeCreated: ").Append(DjstripeCreated).Append("\n");
            sb.Append("  DjstripeUpdated: ").Append(DjstripeUpdated).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Livemode: ").Append(Livemode).Append("\n");
            sb.Append("  Created: ").Append(Created).Append("\n");
            sb.Append("  Metadata: ").Append(Metadata).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ApplicationFeePercent: ").Append(ApplicationFeePercent).Append("\n");
            sb.Append("  BillingCycleAnchor: ").Append(BillingCycleAnchor).Append("\n");
            sb.Append("  BillingThresholds: ").Append(BillingThresholds).Append("\n");
            sb.Append("  CancelAt: ").Append(CancelAt).Append("\n");
            sb.Append("  CancelAtPeriodEnd: ").Append(CancelAtPeriodEnd).Append("\n");
            sb.Append("  CanceledAt: ").Append(CanceledAt).Append("\n");
            sb.Append("  CollectionMethod: ").Append(CollectionMethod).Append("\n");
            sb.Append("  CurrentPeriodEnd: ").Append(CurrentPeriodEnd).Append("\n");
            sb.Append("  CurrentPeriodStart: ").Append(CurrentPeriodStart).Append("\n");
            sb.Append("  DaysUntilDue: ").Append(DaysUntilDue).Append("\n");
            sb.Append("  Discount: ").Append(Discount).Append("\n");
            sb.Append("  EndedAt: ").Append(EndedAt).Append("\n");
            sb.Append("  NextPendingInvoiceItemInvoice: ").Append(NextPendingInvoiceItemInvoice).Append("\n");
            sb.Append("  PendingInvoiceItemInterval: ").Append(PendingInvoiceItemInterval).Append("\n");
            sb.Append("  PendingUpdate: ").Append(PendingUpdate).Append("\n");
            sb.Append("  Quantity: ").Append(Quantity).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  TrialEnd: ").Append(TrialEnd).Append("\n");
            sb.Append("  TrialStart: ").Append(TrialStart).Append("\n");
            sb.Append("  DjstripeOwnerAccount: ").Append(DjstripeOwnerAccount).Append("\n");
            sb.Append("  Customer: ").Append(Customer).Append("\n");
            sb.Append("  DefaultPaymentMethod: ").Append(DefaultPaymentMethod).Append("\n");
            sb.Append("  DefaultSource: ").Append(DefaultSource).Append("\n");
            sb.Append("  PendingSetupIntent: ").Append(PendingSetupIntent).Append("\n");
            sb.Append("  Plan: ").Append(Plan).Append("\n");
            sb.Append("  Schedule: ").Append(Schedule).Append("\n");
            sb.Append("  DefaultTaxRates: ").Append(DefaultTaxRates).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as StripeSubscription);
        }

        /// <summary>
        /// Returns true if StripeSubscription instances are equal
        /// </summary>
        /// <param name="input">Instance of StripeSubscription to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(StripeSubscription input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.DjstripeId == input.DjstripeId ||
                    this.DjstripeId.Equals(input.DjstripeId)
                ) && 
                (
                    this.DjstripeCreated == input.DjstripeCreated ||
                    (this.DjstripeCreated != null &&
                    this.DjstripeCreated.Equals(input.DjstripeCreated))
                ) && 
                (
                    this.DjstripeUpdated == input.DjstripeUpdated ||
                    (this.DjstripeUpdated != null &&
                    this.DjstripeUpdated.Equals(input.DjstripeUpdated))
                ) && 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.Livemode == input.Livemode ||
                    (this.Livemode != null &&
                    this.Livemode.Equals(input.Livemode))
                ) && 
                (
                    this.Created == input.Created ||
                    (this.Created != null &&
                    this.Created.Equals(input.Created))
                ) && 
                (
                    this.Metadata == input.Metadata ||
                    this.Metadata != null &&
                    input.Metadata != null &&
                    this.Metadata.SequenceEqual(input.Metadata)
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.ApplicationFeePercent == input.ApplicationFeePercent ||
                    (this.ApplicationFeePercent != null &&
                    this.ApplicationFeePercent.Equals(input.ApplicationFeePercent))
                ) && 
                (
                    this.BillingCycleAnchor == input.BillingCycleAnchor ||
                    (this.BillingCycleAnchor != null &&
                    this.BillingCycleAnchor.Equals(input.BillingCycleAnchor))
                ) && 
                (
                    this.BillingThresholds == input.BillingThresholds ||
                    this.BillingThresholds != null &&
                    input.BillingThresholds != null &&
                    this.BillingThresholds.SequenceEqual(input.BillingThresholds)
                ) && 
                (
                    this.CancelAt == input.CancelAt ||
                    (this.CancelAt != null &&
                    this.CancelAt.Equals(input.CancelAt))
                ) && 
                (
                    this.CancelAtPeriodEnd == input.CancelAtPeriodEnd ||
                    this.CancelAtPeriodEnd.Equals(input.CancelAtPeriodEnd)
                ) && 
                (
                    this.CanceledAt == input.CanceledAt ||
                    (this.CanceledAt != null &&
                    this.CanceledAt.Equals(input.CanceledAt))
                ) && 
                (
                    this.CollectionMethod == input.CollectionMethod ||
                    this.CollectionMethod.Equals(input.CollectionMethod)
                ) && 
                (
                    this.CurrentPeriodEnd == input.CurrentPeriodEnd ||
                    (this.CurrentPeriodEnd != null &&
                    this.CurrentPeriodEnd.Equals(input.CurrentPeriodEnd))
                ) && 
                (
                    this.CurrentPeriodStart == input.CurrentPeriodStart ||
                    (this.CurrentPeriodStart != null &&
                    this.CurrentPeriodStart.Equals(input.CurrentPeriodStart))
                ) && 
                (
                    this.DaysUntilDue == input.DaysUntilDue ||
                    (this.DaysUntilDue != null &&
                    this.DaysUntilDue.Equals(input.DaysUntilDue))
                ) && 
                (
                    this.Discount == input.Discount ||
                    this.Discount != null &&
                    input.Discount != null &&
                    this.Discount.SequenceEqual(input.Discount)
                ) && 
                (
                    this.EndedAt == input.EndedAt ||
                    (this.EndedAt != null &&
                    this.EndedAt.Equals(input.EndedAt))
                ) && 
                (
                    this.NextPendingInvoiceItemInvoice == input.NextPendingInvoiceItemInvoice ||
                    (this.NextPendingInvoiceItemInvoice != null &&
                    this.NextPendingInvoiceItemInvoice.Equals(input.NextPendingInvoiceItemInvoice))
                ) && 
                (
                    this.PendingInvoiceItemInterval == input.PendingInvoiceItemInterval ||
                    this.PendingInvoiceItemInterval != null &&
                    input.PendingInvoiceItemInterval != null &&
                    this.PendingInvoiceItemInterval.SequenceEqual(input.PendingInvoiceItemInterval)
                ) && 
                (
                    this.PendingUpdate == input.PendingUpdate ||
                    this.PendingUpdate != null &&
                    input.PendingUpdate != null &&
                    this.PendingUpdate.SequenceEqual(input.PendingUpdate)
                ) && 
                (
                    this.Quantity == input.Quantity ||
                    (this.Quantity != null &&
                    this.Quantity.Equals(input.Quantity))
                ) && 
                (
                    this.StartDate == input.StartDate ||
                    (this.StartDate != null &&
                    this.StartDate.Equals(input.StartDate))
                ) && 
                (
                    this.Status == input.Status ||
                    this.Status.Equals(input.Status)
                ) && 
                (
                    this.TrialEnd == input.TrialEnd ||
                    (this.TrialEnd != null &&
                    this.TrialEnd.Equals(input.TrialEnd))
                ) && 
                (
                    this.TrialStart == input.TrialStart ||
                    (this.TrialStart != null &&
                    this.TrialStart.Equals(input.TrialStart))
                ) && 
                (
                    this.DjstripeOwnerAccount == input.DjstripeOwnerAccount ||
                    (this.DjstripeOwnerAccount != null &&
                    this.DjstripeOwnerAccount.Equals(input.DjstripeOwnerAccount))
                ) && 
                (
                    this.Customer == input.Customer ||
                    (this.Customer != null &&
                    this.Customer.Equals(input.Customer))
                ) && 
                (
                    this.DefaultPaymentMethod == input.DefaultPaymentMethod ||
                    (this.DefaultPaymentMethod != null &&
                    this.DefaultPaymentMethod.Equals(input.DefaultPaymentMethod))
                ) && 
                (
                    this.DefaultSource == input.DefaultSource ||
                    (this.DefaultSource != null &&
                    this.DefaultSource.Equals(input.DefaultSource))
                ) && 
                (
                    this.PendingSetupIntent == input.PendingSetupIntent ||
                    (this.PendingSetupIntent != null &&
                    this.PendingSetupIntent.Equals(input.PendingSetupIntent))
                ) && 
                (
                    this.Plan == input.Plan ||
                    (this.Plan != null &&
                    this.Plan.Equals(input.Plan))
                ) && 
                (
                    this.Schedule == input.Schedule ||
                    (this.Schedule != null &&
                    this.Schedule.Equals(input.Schedule))
                ) && 
                (
                    this.DefaultTaxRates == input.DefaultTaxRates ||
                    this.DefaultTaxRates != null &&
                    input.DefaultTaxRates != null &&
                    this.DefaultTaxRates.SequenceEqual(input.DefaultTaxRates)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = hashCode * 59 + this.DjstripeId.GetHashCode();
                if (this.DjstripeCreated != null)
                    hashCode = hashCode * 59 + this.DjstripeCreated.GetHashCode();
                if (this.DjstripeUpdated != null)
                    hashCode = hashCode * 59 + this.DjstripeUpdated.GetHashCode();
                if (this.Id != null)
                    hashCode = hashCode * 59 + this.Id.GetHashCode();
                if (this.Livemode != null)
                    hashCode = hashCode * 59 + this.Livemode.GetHashCode();
                if (this.Created != null)
                    hashCode = hashCode * 59 + this.Created.GetHashCode();
                if (this.Metadata != null)
                    hashCode = hashCode * 59 + this.Metadata.GetHashCode();
                if (this.Description != null)
                    hashCode = hashCode * 59 + this.Description.GetHashCode();
                if (this.ApplicationFeePercent != null)
                    hashCode = hashCode * 59 + this.ApplicationFeePercent.GetHashCode();
                if (this.BillingCycleAnchor != null)
                    hashCode = hashCode * 59 + this.BillingCycleAnchor.GetHashCode();
                if (this.BillingThresholds != null)
                    hashCode = hashCode * 59 + this.BillingThresholds.GetHashCode();
                if (this.CancelAt != null)
                    hashCode = hashCode * 59 + this.CancelAt.GetHashCode();
                hashCode = hashCode * 59 + this.CancelAtPeriodEnd.GetHashCode();
                if (this.CanceledAt != null)
                    hashCode = hashCode * 59 + this.CanceledAt.GetHashCode();
                hashCode = hashCode * 59 + this.CollectionMethod.GetHashCode();
                if (this.CurrentPeriodEnd != null)
                    hashCode = hashCode * 59 + this.CurrentPeriodEnd.GetHashCode();
                if (this.CurrentPeriodStart != null)
                    hashCode = hashCode * 59 + this.CurrentPeriodStart.GetHashCode();
                if (this.DaysUntilDue != null)
                    hashCode = hashCode * 59 + this.DaysUntilDue.GetHashCode();
                if (this.Discount != null)
                    hashCode = hashCode * 59 + this.Discount.GetHashCode();
                if (this.EndedAt != null)
                    hashCode = hashCode * 59 + this.EndedAt.GetHashCode();
                if (this.NextPendingInvoiceItemInvoice != null)
                    hashCode = hashCode * 59 + this.NextPendingInvoiceItemInvoice.GetHashCode();
                if (this.PendingInvoiceItemInterval != null)
                    hashCode = hashCode * 59 + this.PendingInvoiceItemInterval.GetHashCode();
                if (this.PendingUpdate != null)
                    hashCode = hashCode * 59 + this.PendingUpdate.GetHashCode();
                if (this.Quantity != null)
                    hashCode = hashCode * 59 + this.Quantity.GetHashCode();
                if (this.StartDate != null)
                    hashCode = hashCode * 59 + this.StartDate.GetHashCode();
                hashCode = hashCode * 59 + this.Status.GetHashCode();
                if (this.TrialEnd != null)
                    hashCode = hashCode * 59 + this.TrialEnd.GetHashCode();
                if (this.TrialStart != null)
                    hashCode = hashCode * 59 + this.TrialStart.GetHashCode();
                if (this.DjstripeOwnerAccount != null)
                    hashCode = hashCode * 59 + this.DjstripeOwnerAccount.GetHashCode();
                if (this.Customer != null)
                    hashCode = hashCode * 59 + this.Customer.GetHashCode();
                if (this.DefaultPaymentMethod != null)
                    hashCode = hashCode * 59 + this.DefaultPaymentMethod.GetHashCode();
                if (this.DefaultSource != null)
                    hashCode = hashCode * 59 + this.DefaultSource.GetHashCode();
                if (this.PendingSetupIntent != null)
                    hashCode = hashCode * 59 + this.PendingSetupIntent.GetHashCode();
                if (this.Plan != null)
                    hashCode = hashCode * 59 + this.Plan.GetHashCode();
                if (this.Schedule != null)
                    hashCode = hashCode * 59 + this.Schedule.GetHashCode();
                if (this.DefaultTaxRates != null)
                    hashCode = hashCode * 59 + this.DefaultTaxRates.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // Id (string) maxLength
            if(this.Id != null && this.Id.Length > 255)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Id, length must be less than 255.", new [] { "Id" });
            }

            // ApplicationFeePercent (decimal?) pattern
            Regex regexApplicationFeePercent = new Regex(@"^\\d{0,3}(?:\\.\\d{0,2})?$", RegexOptions.CultureInvariant);
            if (false == regexApplicationFeePercent.Match(this.ApplicationFeePercent).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ApplicationFeePercent, must match a pattern of " + regexApplicationFeePercent, new [] { "ApplicationFeePercent" });
            }

            // DaysUntilDue (int?) maximum
            if(this.DaysUntilDue > (int?)2147483647)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DaysUntilDue, must be a value less than or equal to 2147483647.", new [] { "DaysUntilDue" });
            }

            // DaysUntilDue (int?) minimum
            if(this.DaysUntilDue < (int?)-2147483648)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DaysUntilDue, must be a value greater than or equal to -2147483648.", new [] { "DaysUntilDue" });
            }

            // Quantity (int?) maximum
            if(this.Quantity > (int?)2147483647)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Quantity, must be a value less than or equal to 2147483647.", new [] { "Quantity" });
            }

            // Quantity (int?) minimum
            if(this.Quantity < (int?)-2147483648)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Quantity, must be a value greater than or equal to -2147483648.", new [] { "Quantity" });
            }

            yield break;
        }
    }

}
